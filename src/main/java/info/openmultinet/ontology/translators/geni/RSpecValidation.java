package info.openmultinet.ontology.translators.geni;

import info.openmultinet.ontology.Parser;
import info.openmultinet.ontology.exceptions.InvalidModelException;
import info.openmultinet.ontology.translators.AbstractConverter;
import info.openmultinet.ontology.translators.geni.jaxb.advertisement.RSpecContents;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;

import javax.xml.bind.JAXBException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLStreamException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.custommonkey.xmlunit.DetailedDiff;
import org.custommonkey.xmlunit.Diff;
import org.custommonkey.xmlunit.Difference;
import org.custommonkey.xmlunit.ElementNameAndAttributeQualifier;
import org.custommonkey.xmlunit.Validator;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.hp.hpl.jena.rdf.model.InfModel;
import com.hp.hpl.jena.rdf.model.Model;

public class RSpecValidation {

	/**
	 * returns the number of non-recoverable XMLunit differences (errors) in
	 * proportion to the number of nodes in the rspec
	 * 
	 * @param input
	 *            RSpec as string
	 * @return
	 */
	static public double getProportionalError(String input) {

		String output = completeRoundtrip(input);
		String inputNew = null;
		String outputNew = null;

		// clean up input doc
		Document inputDoc;
		try {
			inputDoc = RSpecValidation.loadXMLFromString(input);
			RSpecValidation.wipeRootNamespaces(inputDoc);
			inputNew = RSpecValidation.getStringFromXml(inputDoc);
		} catch (Exception e) {
			e.printStackTrace();
		}

		// clean up output doc
		Document outputDoc = null;
		try {
			outputDoc = RSpecValidation.loadXMLFromString(output);
			RSpecValidation.wipeRootNamespaces(outputDoc);
			outputNew = RSpecValidation.getStringFromXml(outputDoc);
		} catch (Exception e) {

			e.printStackTrace();
		}

		// get number of differences and calculate proportional error rate
		int numDiffs = getNumberDiffs(inputNew, outputNew);
		int nodeCount = outputDoc.getElementsByTagName("*").getLength();
		double errorRate = ((double) numDiffs) / (2 * nodeCount);
		errorRate = errorRate < 1 ? errorRate : 1;

		return errorRate;
	}

	/**
	 * returns the number of non-recoverable differences generated by XMLunit
	 * 
	 * @param input
	 *            RSpec
	 * @param output
	 *            RSpec
	 * @return
	 */
	private static int getNumberDiffs(String input, String output) {

		org.custommonkey.xmlunit.XMLUnit.setIgnoreWhitespace(true);
		org.custommonkey.xmlunit.XMLUnit.setIgnoreComments(true);

		Diff d = null;
		try {
			d = new Diff(input, output);
		} catch (SAXException | IOException e) {

			e.printStackTrace();
		}

		d.overrideElementQualifier(new ElementNameAndAttributeQualifier());
		DetailedDiff myDiff = new DetailedDiff(d);

		int numDiffs = 0;
		for (@SuppressWarnings("rawtypes")
		java.util.Iterator iter = myDiff.getAllDifferences().iterator(); iter
				.hasNext();) {
			Difference diff = (Difference) iter.next();
			if (!diff.isRecoverable()) {
				numDiffs++;
			}
		}
		return numDiffs;

	}

	/**
	 * loads and XML document from a string
	 * 
	 * @param xml
	 * @return
	 * @throws Exception
	 */
	public static Document loadXMLFromString(String xml) {

		Document xmlDoc = null;
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setNamespaceAware(true);

		try {
			DocumentBuilder builder = factory.newDocumentBuilder();
			xmlDoc = builder.parse(new ByteArrayInputStream(xml.getBytes()));
		} catch (SAXException | IOException | ParserConfigurationException e) {

			e.printStackTrace();
		}

		return xmlDoc;
	}

	/**
	 * gets a string from an XML document
	 * 
	 * @param xml
	 * @return
	 * @throws Exception
	 */
	public static final String getStringFromXml(Document xml) {

		Transformer tf;
		Writer out = null;
		try {
			tf = TransformerFactory.newInstance().newTransformer();
			tf.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
			tf.setOutputProperty(OutputKeys.INDENT, "yes");
			out = new StringWriter();
			tf.transform(new DOMSource(xml), new StreamResult(out));
		} catch (TransformerFactoryConfigurationError | TransformerException e) {
			e.printStackTrace();
		}

		return out.toString();

	}

	/**
	 * wipes all attributes in the RSpec node, except for "type"
	 * 
	 * @param xml
	 */
	public static void wipeRootNamespaces(Document xml) {

		Node root = xml.getElementsByTagName("rspec").item(0);
		NodeList rootchildren = root.getChildNodes();
		Element newroot = xml.createElement(root.getNodeName());

		String type = root.getAttributes().getNamedItem("type").getNodeValue();
		newroot.setAttribute("type", type);

		for (int i = 0; i < rootchildren.getLength(); i++) {
			newroot.appendChild(rootchildren.item(i).cloneNode(true));
		}
		xml.replaceChild(newroot, root);
	}

	/**
	 * returns the RSpec type, "advertisement", "manifest", or "request"
	 * 
	 * @param xml
	 * @return
	 */
	public static String getType(String input) {
		Document xml = null;
		String type = null;

		try {
			xml = RSpecValidation.loadXMLFromString(input);
			Node root = xml.getElementsByTagName("rspec").item(0);
			type = root.getAttributes().getNamedItem("type").getNodeValue();
		} catch (Exception e1) {
			e1.printStackTrace();
		}

		return type;
	}

	/**
	 * generates an Open Multinet model from an RSpec, then generates a new
	 * RSpec from the generated model and returns the new RSpec as a string
	 * 
	 * @param input
	 * @return
	 */
	public static String completeRoundtrip(String input) {

		String output = null;
		Model model;

		String type = getType(input);

		InputStream inputStream = null;
		try {
			inputStream = IOUtils.toInputStream(input, "UTF-8");
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		if (type.equals("advertisement")) {
			try {
				AdvertisementConverter converter = new AdvertisementConverter();
				RSpecContents rspec = converter.getRspec(inputStream);
				model = converter.getModel(rspec);
				output = converter.getRSpec(model);
			} catch (JAXBException | InvalidModelException | XMLStreamException e) {
				e.printStackTrace();
			}
		}

		if (type.equals("manifest")) {
			try {
				model = ManifestConverter.getModel(inputStream);
				InfModel infModel = new Parser(model).getInfModel();
				output = ManifestConverter.getRSpec(infModel,
						"instageni.gpolab.bbn.com");
			} catch (JAXBException | InvalidModelException e) {
				e.printStackTrace();
			}
		}

		if (type.equals("request")) {
			try {
				model = RequestConverter.getModel(inputStream);
				output = RequestConverter.getRSpec(model);
			} catch (JAXBException | InvalidModelException e) {
				e.printStackTrace();
			}
		}
		return output;
	}

	/**
	 * compares an RSpec string against the XSD file using XMLUnit
	 * 
	 * @param input
	 *            RSpec string
	 * @return whether RSpec is valid or not
	 */
	public static boolean validateRspecXMLUnit(String input) {
		boolean isValid = false;
		InputSource is;

		try {
			is = new InputSource(new StringReader(input));
			Validator v = new Validator(is);
			v.useXMLSchema(true);
			File schema = null;

			// get rspec as string in order to check type
			String type = RSpecValidation.getType(input);

			if (type != null) {
				// set schema according to rspec type
				if (type.equals("advertisement")) {
					schema = new File(
							"./src/main/resources/geni/advertisement/ad.xsd");
				}

				if (type.equals("manifest")) {
					schema = new File(
							"./src/main/resources/geni/manifest/manifest.xsd");
				}

				if (type.equals("request")) {
					schema = new File(
							"./src/main/resources/geni/request/request.xsd");
				}
				
				// check against XSD whether rspec is valid or not
				v.setJAXP12SchemaSource(schema);
				isValid = v.isValid();
			}

		} catch (SAXException e) {
			e.printStackTrace();
		}
		return isValid;
	}

	/**
	 * compares an RSpec string against the XSD file using RSpecLint and returns
	 * whether the file is a valide RSpec or not.
	 * 
	 * Note: only tested on Mac OS.
	 * 
	 * Note: requires executable instance of RDFLint in src folder
	 * http://trac.gpolab.bbn.com/gcf/attachment/wiki/OmniTroubleShoot/rspeclint
	 * 
	 * @param input
	 *            RSpec string
	 * @return whether RSpec is valid or not
	 */
	public static boolean rspecLintMacOnly(String filepath) {

		String rspecString = null;

		try {
			rspecString = AbstractConverter.toString(filepath);
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		filepath = "src/test/resources" + filepath;

		String command1a = "./src/rspeclint";
		String command1b = "http://www.geni.net/resources/rspec/3";

		String command1c = null;
		String type = RSpecValidation.getType(rspecString);

		switch (type) {
		case "advertisement":
			command1c = "http://www.geni.net/resources/rspec/3/ad.xsd";
			break;
		case "manifest":
			command1c = "http://www.geni.net/resources/rspec/3/manifest.xsd";
			break;
		case "request":
			command1c = "http://www.geni.net/resources/rspec/3/request.xsd";
			break;
		}

		if (command1c != null) {
			String[] commands = new String[4];
			commands[0] = command1a;
			commands[1] = command1b;
			commands[2] = command1c;
			commands[3] = filepath;

			Process process;
			try {
				process = Runtime.getRuntime().exec(commands);
				process.waitFor();
				if (process.exitValue() == 0) {
					return true;
				}
			} catch (Exception e) {
				System.out.println("Exception: " + e.toString());
			}
		} else {
			System.out.println("Error: Unable to determin RSpec type.");
		}
		return false;
	}

	/**
	 * Returns whether a files extension is that of an RSpec
	 * 
	 * @param file
	 * @return
	 */
	public static boolean rspecFileExtension(File file) {
		String fileExt = null;
		try {
			fileExt = FilenameUtils.getExtension(file.getCanonicalPath());
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		boolean fileExtensionOK = fileExt.equals("xml")
				|| fileExt.equals("manifest") || fileExt.equals("request")
				|| fileExt.equals("rspec");

		return fileExtensionOK;
	}
}