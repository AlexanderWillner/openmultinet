package info.openmultinet.ontology.translators.xmlunit;

import info.openmultinet.ontology.Parser;
import info.openmultinet.ontology.exceptions.InvalidModelException;
import info.openmultinet.ontology.translators.AbstractConverter;
import info.openmultinet.ontology.translators.geni.AdvertisementConverter;
import info.openmultinet.ontology.translators.geni.ManifestConverter;
import info.openmultinet.ontology.translators.geni.RequestConverter;
import info.openmultinet.ontology.translators.geni.jaxb.advertisement.RSpecContents;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.JAXBException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLStreamException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.custommonkey.xmlunit.DetailedDiff;
import org.custommonkey.xmlunit.Diff;
import org.custommonkey.xmlunit.Difference;
import org.custommonkey.xmlunit.ElementNameAndAttributeQualifier;
import org.custommonkey.xmlunit.XMLUnit;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import com.hp.hpl.jena.rdf.model.InfModel;
import com.hp.hpl.jena.rdf.model.Model;

public class ProportionalError {

	/**
	 * returns the number of non-recoverable XMLunit differences (errors) in
	 * proportion to the number of nodes in the rspec
	 * 
	 * @param input
	 *            RSpec as string
	 * @return
	 */
	static public double getProportionalError(String input) {

		String output = ProportionalError.completeRoundtrip(input);
		String inputNew = null;
		String outputNew = null;

		// clean up input doc
		Document inputDoc;
		try {
			inputDoc = ProportionalError.loadXMLFromString(input);
			ProportionalError.wipeRootNamespaces(inputDoc);
			inputNew = ProportionalError.getStringFromXml(inputDoc);
		} catch (Exception e) {
			e.printStackTrace();
		}

		// clean up output doc
		Document outputDoc = null;
		try {
			outputDoc = ProportionalError.loadXMLFromString(output);
			ProportionalError.wipeRootNamespaces(outputDoc);
			outputNew = ProportionalError.getStringFromXml(outputDoc);
		} catch (Exception e) {

			e.printStackTrace();
		}

		// get number of differences and calculate proportional error rate
		int numDiffs = getNumberDiffs(inputNew, outputNew);
		int nodeCount = outputDoc.getElementsByTagName("*").getLength();
		double errorRate = ((double) numDiffs) / (2 * nodeCount);
		errorRate = errorRate < 1 ? errorRate : 1;

		return errorRate;
	}

	/**
	 * returns the number of non-recoverable differences generated by XMLunit
	 * 
	 * @param input
	 *            RSpec
	 * @param output
	 *            RSpec
	 * @return
	 */
	private static int getNumberDiffs(String input, String output) {
		
		XMLUnit.setIgnoreWhitespace(true);
		XMLUnit.setIgnoreComments(true);
		
		Diff d = null;
		try {
			d = new Diff(input, output);
		} catch (SAXException | IOException e) {

			e.printStackTrace();
		}

		d.overrideElementQualifier(new ElementNameAndAttributeQualifier());
		DetailedDiff myDiff = new DetailedDiff(d);

		int numDiffs = 0;
		for (@SuppressWarnings("rawtypes")
		java.util.Iterator iter = myDiff.getAllDifferences().iterator(); iter
				.hasNext();) {
			Difference diff = (Difference) iter.next();
			if (!diff.isRecoverable()) {
				numDiffs++;
			}
		}
		return numDiffs;

	}

	/**
	 * loads and XML document from a string
	 * 
	 * @param xml
	 * @return
	 * @throws Exception
	 */
	public static Document loadXMLFromString(String xml) {

		Document xmlDoc = null;
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setNamespaceAware(true);

		try {
			DocumentBuilder builder = factory.newDocumentBuilder();
			xmlDoc = builder.parse(new ByteArrayInputStream(xml.getBytes()));
		} catch (SAXException | IOException | ParserConfigurationException e) {

			e.printStackTrace();
		}

		return xmlDoc;
	}

	/**
	 * gets a string from an XML document
	 * 
	 * @param xml
	 * @return
	 * @throws Exception
	 */
	public static final String getStringFromXml(Document xml) {

		Transformer tf;
		Writer out = null;
		try {
			tf = TransformerFactory.newInstance().newTransformer();
			tf.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
			tf.setOutputProperty(OutputKeys.INDENT, "yes");
			out = new StringWriter();
			tf.transform(new DOMSource(xml), new StreamResult(out));
		} catch (TransformerFactoryConfigurationError | TransformerException e) {
			e.printStackTrace();
		}

		return out.toString();

	}

	/**
	 * wipes all attributes in the RSpec node, except for "type"
	 * 
	 * @param xml
	 */
	public static void wipeRootNamespaces(Document xml) {

		Node root = xml.getElementsByTagName("rspec").item(0);
		NodeList rootchildren = root.getChildNodes();
		Element newroot = xml.createElement(root.getNodeName());

		String type = root.getAttributes().getNamedItem("type").getNodeValue();
		newroot.setAttribute("type", type);

		for (int i = 0; i < rootchildren.getLength(); i++) {
			newroot.appendChild(rootchildren.item(i).cloneNode(true));
		}
		xml.replaceChild(newroot, root);
	}

	/**
	 * returns the RSpec type, "advertisement", "manifest", or "request"
	 * 
	 * @param xml
	 * @return
	 */
	public static String getType(Document xml) {

		Node root = xml.getElementsByTagName("rspec").item(0);
		String type = root.getAttributes().getNamedItem("type").getNodeValue();
		return type;
	}

	/**
	 * generates an Open Multinet model from an RSpec, then generates a new
	 * RSpec from the generated model and returns the new RSpec as a string
	 * 
	 * @param input
	 * @return
	 */
	public static String completeRoundtrip(String input) {

		String output = null;
		String type = null;
		Model model;

		try {
			Document inputDoc = ProportionalError.loadXMLFromString(input);
			type = getType(inputDoc);
		} catch (Exception e1) {
			e1.printStackTrace();
		}

		InputStream inputStream = null;
		try {
			inputStream = IOUtils.toInputStream(input, "UTF-8");
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		if (type.equals("advertisement")) {
			try {
				AdvertisementConverter converter = new AdvertisementConverter();
				RSpecContents rspec = converter.getRspec(inputStream);
				model = converter.getModel(rspec);
				output = converter.getRSpec(model);
			} catch (JAXBException | InvalidModelException | XMLStreamException e) {
				e.printStackTrace();
			}
		}

		if (type.equals("manifest")) {
			try {
				model = ManifestConverter.getModel(inputStream);
				InfModel infModel = new Parser(model).getInfModel();
				output = ManifestConverter.getRSpec(infModel,
						"instageni.gpolab.bbn.com");
			} catch (JAXBException | InvalidModelException e) {
				e.printStackTrace();
			}
		}

		if (type.equals("request")) {
			try {
				model = RequestConverter.getModel(inputStream);
				output = RequestConverter.getRSpec(model);
			} catch (JAXBException | InvalidModelException e) {
				e.printStackTrace();
			}
		}
		return output;
	}

	public static void main(String[] args) {

		System.out
				.println("==========================================================");

		// File path = new File("./src/test/resources/geni/advertisement");
		// File path = new File("./src/test/resources/geni/manifest"); //
		// File path = new File("./src/test/resources/omn/paper2015iswc"); //
		// File path = new File("./src/test/resources/geni/request"); //
		// File path = new File("./src/test/resources/geni/protogeni"); //
		// File path = new File("./src/test/resources/geni/gimiv3"); //
		File path = new File("./src/test/resources/geni/fed4fire"); //

		try {
			System.out.println("Testing all RSpecs in folder:");
			System.out.println("canon path " + path.getCanonicalPath());
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		File[] files = null;
		if (path.listFiles() != null) {
			files = path.listFiles();
		}

		System.out.println();
		System.out
				.println("==========================================================");

		List<Double> errorAds = new ArrayList<Double>();
		List<Double> errorManifests = new ArrayList<Double>();
		List<Double> errorRequests = new ArrayList<Double>();
		ArrayList<List<Double>> errorRates = new ArrayList<List<Double>>();
		errorRates.add(errorAds);
		errorRates.add(errorManifests);
		errorRates.add(errorRequests);

		for (int i = 0; i < files.length; i++) {
			String fileExt = null;
			try {
				fileExt = FilenameUtils.getExtension(files[i]
						.getCanonicalPath());
			} catch (IOException e1) {
				e1.printStackTrace();
			}

			boolean fileExtensionOK = fileExt.equals("xml")
					|| fileExt.equals("manifest") || fileExt.equals("request");

			if (files[i].isFile() && fileExtensionOK) {
				String rspecString = null;
				try {
					System.out.println(files[i].getPath());

					System.out.println(files[i].getPath().substring(20));
					// note: substring(20) specifically gets rid of
					// "./src/test/resources"), so must be changed if a
					// different path is used
					rspecString = AbstractConverter.toString(files[i].getPath()
							.substring(20));
					String type = getType(loadXMLFromString(rspecString));
					double errorRate = getProportionalError(rspecString);
					System.out.println("Error: " + errorRate);

					switch (type) {
					case "advertisement":
						errorAds.add(errorRate);
						break;
					case "manifest":
						errorManifests.add(errorRate);
						break;
					case "request":
						errorRequests.add(errorRate);
						break;
					}

					System.out
							.println("==========================================================");
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

		double sum = 0;
		for (int i = 0; i < errorRates.size(); i++) {
			double interimSum = 0;
			for (int j = 0; j < errorRates.get(i).size(); j++) {
				interimSum += errorRates.get(i).get(j);
			}

			String type = null;
			switch (i) {
			case 0:
				type = "advertisement";
				break;
			case 1:
				type = "manifest";
				break;
			case 2:
				type = "request";
				break;
			}
			System.out.println("Total error for " + errorRates.get(i).size()
					+ " " + type + "s " + interimSum);
			sum += interimSum;
		}

		System.out.println("Total error for " + errorRates.size() + " files: "
				+ sum);
		System.out.println("Comprising " + errorAds.size() + " ads, "
				+ errorManifests.size() + " manifests, and "
				+ errorRequests.size() + " requests.");
		double average = sum / files.length;
		System.out.println("Average error: " + average);

	}
}